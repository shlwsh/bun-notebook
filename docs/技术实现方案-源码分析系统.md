# 源码分析与AI开发管控系统 - 技术实现方案

## 1. 总体架构设计

本系统采用 **C/S (Client-Server)** 架构，针对本地开发环境进行优化。核心在于"高性能静态分析" (High Performance Static Analysis) 与 "Git深度集成"。

```mermaid
graph TB
    subgraph "前端应用 (Client)"
        UI[React单页应用]
        Store[状态管理 (Zustand)]
        
        UI --> Store
        
        subgraph "可视化组件"
            GraphView[架构拓扑图 (React Flow)]
            GitView[Git版本演进图]
            ReportView[治理分析报告]
        end
        UI --> GraphView
        UI --> GitView
        UI --> ReportView
    end

    subgraph "后端服务 (Server - Bun Runtime)"
        API[HTTP API (ElysiaJS)]
        
        GitService[Git操作服务]
        AnalysisQueue[分析任务队列]
        
        subgraph "核心分析引擎"
            Parser[代码解析器 (Tree-sitter)]
            DependencyBuilder[依赖构建器]
            GovernanceEngine[风险治理引擎]
        end
        
        subgraph "数据存储层"
            GraphDB[图数据库 (Neo4j/Graphology)]
            CacheDB[SQLite (缓存/元数据)]
        end
        
        API --> AnalysisQueue
        API --> GitService
        
        AnalysisQueue --> Parser
        Parser --> DependencyBuilder
        DependencyBuilder --> GraphDB
        DependencyBuilder --> GovernanceEngine
        
        API --> GraphDB
        API --> CacheDB
    end
```

---

## 2. 技术选型

### 2.1 后端技术栈 (Performance First)

*   **Runtime**: **Bun**
    *   *理由*: 极致的启动速度和运行性能，原生支持TypeScript，内置SQLite和WebSocket，非常适合本地高性能工具。
*   **Web Framework**: **ElysiaJS**
    *   *理由*: 专为Bun优化，类型安全，性能极高。
*   **Code Parsing**: **Tree-sitter**
    *   *理由*: 增量解析能力强，容错性好（能解析AI生成的半成品代码），多语言支持完善。
*   **File Watching**: **Chokidar** (或Bun原生`watch`)
    *   *理由*: 稳定可靠的文件系统监听。
*   **Graph Data**: **Graphology** (内存) + **SQLite** (持久化)
    *   *理由*: 纯内存图操作速度最快，适合实时分析；SQLite用于存储历史记录、配置和不经常变动的元数据。

### 2.2 前端技术栈 (User Experience First)

*   **Framework**: **React 18 + Vite**
*   **State Management**: **Zustand** (轻量级，适合频繁状态更新)
*   **Visualization**:
    *   **React Flow / XYFlow**: 用于绘制可交互的节点流程图、依赖图（性能好，定制性强）。
    *   **ECharts**: 用于绘制统计图表（热力图、仪表盘）。
*   **Styling**: **TailwindCSS** + **Shadcn/UI** (构建现代化、Premium感的界面)。

---

## 3. 核心模块详细设计

### 3.1 分析流水线 (The Pipeline)

分析过程主要由用户手动触发、定时触发或Git提交钩子触发：

1.  **Trigger**: 
    *   Manual Analysis: 用户点“全量分析”。
    *   Git Hook: 检测到新的Commit。
    *   File Watcher: (可选) 检测到文件保存，进行轻量级语法检查。
2.  **Snapshot Loading**: 加载指定版本（HEAD或特定Commit）的代码快照。
3.  **Parsing & Extraction**: 
    *   使用Parallel Tree-sitter进行并行解析。
    *   提取符号表(Symbol Table)和引用关系。
4.  **Graph Construction**: 
    *   构建/更新依赖图谱。
    *   执行传递闭包算法，计算间接依赖。
5.  **Governance Check**: 
    *   运行预定义的架构规则 (Architecture Rules)。
    *   生成违规报告 (Violation Report)。
6.  **Persistence**: 将结果存入数据库，供前端查询。

### 3.2 数据模型设计 (Schema)

#### 3.2.1 核心实体 (Graph Nodes)
*   **System**: 整个项目。
*   **Module**: 目录/包。
*   **SourceFile**: 文件。
*   **Class/Interface**: 类结构。
*   **Function/Method**: 函数。

#### 3.2.2 变更模型 (SQLite)

```sql
CREATE TABLE commit_analysis (
    id TEXT PRIMARY KEY, -- Commit Hash
    author TEXT,
    message TEXT,
    analyzed_at DATETIME,
    quality_score INTEGER,
    architecture_violations JSON
);

CREATE TABLE file_impact (
    commit_id TEXT,
    file_path TEXT,
    change_type TEXT,
    direct_dependencies TEXT, -- JSON Array
    indirect_impact_score INTEGER
);
```

### 3.3 风险管控逻辑

系统包含一个轻量级规则引擎，在Graph Update后触发：

*   **规则 1: 循环依赖检测**
    *   算法: Tarjan算法或简单的DFS环检测。
    *   触发: 任何 `IMPORTS` 边增加时。
*   **规则 2: API 破坏性变更**
    *   逻辑: 如果一个 `public` 方法的签名(参数/返回值)发生变化，且依赖图中存在该方法的外部调用者。
    *   行为: 标记该节点为 `CRITICAL_RISK`，前端显示红色警示。
*   **规则 3: 孤立节点检测**
    *   逻辑: 仅被创建但未被引用的类/方法（可能是AI产生的死代码）。

---

## 4. 接口设计 (API)

### 4.1 REST API (HTTP)

*   `GET /api/project/status`: 获取项目当前健康度、文件数、代码行数。
*   `GET /api/graph/full`: 获取全量架构图数据 (JSON格式, 节点+边)。
*   `GET /api/graph/filter?module=xxx`: 获取特定模块的子图。
*   `GET /api/history`: 获取变更历史记录。
*   `POST /api/config`: 更新分析配置 (忽略文件夹、规则阈值)。

### 4.2 WebSocket Events

*   `server -> client`: `graph:update`
    *   Payload: `{ type: 'node_updated', node: {...}, impact: [...] }`
*   `server -> client`: `risk:alert`
    *   Payload: `{ level: 'high', message: 'Circular dependency detected in AuthService' }`

---

## 5. 项目结构规划

```
bun-codeview/
├── backend/
│   ├── src/
│   │   ├── analyzer/       # Tree-sitter解析逻辑
│   │   ├── graph/          # 图数据结构与算法
│   │   ├── watcher/        # 文件监听
│   │   ├── server.ts       # Elysia服务入口
│   │   └── config.ts
│   └── package.json
├── frontend/
│   ├── src/
│   │   ├── components/
│   │   │   ├── GraphCanvas.tsx  # 图可视化
│   │   │   └── Dashboard.tsx
│   │   ├── store/          # Zustand状态
│   │   └── App.tsx
│   └── package.json
├── shared/                 # 前后端共享类型定义
│   └── types.ts
└── docs/                   # 文档
```

## 6. 开发阶段规划

1.  **Phase 1: 核心解析与可视化 (MVP)**:
    *   搭建基础应用架构 (Bun + React)。
    *   实现Java/TypeScript的静态解析 (Tree-sitter)。
    *   完成基础架构图（System/Module层级）展示。
2.  **Phase 2: Git集成与变更分析**:
    *   集成Local Git，读取Commit历史。
    *   实现Diff解析，关联代码节点。
    *   开发影响范围分析算法。
3.  **Phase 3: AI治理规则引擎**:
    *   实现架构分层检查规则。
    *   开发API兼容性检测规则。
    *   生成治理报表。

---

此方案利用Bun的高性能和Tree-sitter的强大解析能力，能够满足"Vibe Coding"场景下对瞬时反馈的严苛要求。
