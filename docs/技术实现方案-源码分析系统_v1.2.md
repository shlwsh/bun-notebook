# 源码分析与AI开发管控系统 - 技术实现方案

## 1. 总体架构设计

本系统采用 **C/S (Client-Server)** 架构，以 **High Performance** (高性能) 和 **AI Experience** (AI体验) 为核心设计原则。

```mermaid
graph TB
    subgraph "前端应用 (Client)"
        UI[React单页应用]
        Store[状态管理 (Zustand)]
        
        UI --> Store
        
        subgraph "可视化组件"
            GraphView[架构拓扑图 (React Flow)]
            GitView[Git版本演进图]
            ReportView[治理分析报告]
        end
        UI --> GraphView
        UI --> GitView
        UI --> ReportView
    end

    subgraph "后端服务 (Server - Bun Runtime)"
        API[HTTP API (ElysiaJS)]
        
        GitService[Git操作服务]
        AnalysisQueue[分析任务队列]
        
        subgraph "核心分析引擎"
            Parser[代码解析器 (Tree-sitter WASM)]
            DependencyBuilder[依赖构建器]
            GovernanceEngine[风险治理引擎]
        end
        
        subgraph "数据存储层"
            GraphDB[图数据库 (Graphology)]
            CacheDB[SQLite (Bun Native)]
        end
        
        API --> AnalysisQueue
        API --> GitService
        
        AnalysisQueue --> Parser
        Parser --> DependencyBuilder
        DependencyBuilder --> GraphDB
        DependencyBuilder --> GovernanceEngine
        
        API --> GraphDB
        API --> CacheDB
    end
```

---

## 2. 技术选型 (Vibe Coding Optimized)

### 2.1 后端技术栈

*   **Runtime**: **Bun** (主) + **Node.js** (兼容)
    *   *理由*: Bun 提供极致的冷启动速度和开发体验（Zero Config TypeScript），非常适合 AI 辅助开发模式。Node.js 仅作为极端信创环境的兜底方案。
*   **Web Framework**: **ElysiaJS**
    *   *理由*: 
        1. **Bun Native**: 为 Bun 量身定制，性能接近 Go/Rust。
        2. **Type Safety**: 强大的端到端类型推导。
        3. **Node Compatible**: 使用 `@elysiajs/node` 插件可一键降级运行在 Node.js 上。
*   **Code Parsing**: **Tree-sitter (WASM)**
    *   *理由*: 使用 WASM 版本可确保在任何架构（包括龙芯、ARMv8、x86）上行为一致，无需本地编译 C++ 绑定。
*   **Graph Data**: **Graphology** + **SQLite**
    *   *理由*: Bun 原生内置了高性能 SQLite 驱动（比 Node `better-sqlite3` 更快）。

### 2.2 前端技术栈

*   **Framework**: **React 18 + Vite**
*   **Visualization**: **React Flow**
*   **Styling**: **TailwindCSS** + **Shadcn/UI**

---

## 3. 核心模块详细设计

### 3.1 分析流水线 (The Pipeline)

分析过程主要由用户手动触发或 Git 提交自动触发：

1.  **Trigger**: 
    *   Manual / Git Hook (pre-commit)。
2.  **Snapshot Loading**: 加载代码快照。
3.  **Parsing & Extraction**: 
    *   使用 `Bun.spawn` 或 Worker 并行运行 Tree-sitter WASM 解析。
4.  **Graph Construction**: 
    *   构建依赖图谱，计算 Metrics（圈复杂度等）。
5.  **Governance Check**: 
    *   检测 API 变更、循环依赖。
6.  **Persistence**: 存入 SQLite。

### 3.2 兼容性降级策略 (Polyfill Strategy)

针对不支持 Bun 的环境（如龙芯旧版），系统提供降级入口：

1.  **Entry Point A (Default)**: `bun run src/index.ts`
    *   使用 `Bun.serve`。
    *   使用 `bun:sqlite`。
2.  **Entry Point B (Legacy)**: `node dist/index.js`
    *   代码编译为标准 JS。
    *   使用 `@elysiajs/node` 接管 HTTP 服务。
    *   使用 `better-sqlite3` 替换 `bun:sqlite` (通过依赖注入/策略模式实现)。

---

## 4. 接口设计 (API)

### 4.1 REST API (ElysiaJS)

```typescript
// 示例：类型安全的 API 定义
new Elysia()
    .get('/project/status', () => db.getStatus())
    .post('/analyze', ({ body }) => analysisService.run(body.path), {
        body: t.Object({ path: t.String() }) 
    })
```

---

## 5. 项目结构规划

```
bun-codeview/
├── backend/
│   ├── src/
│   │   ├── analyzer/       # 核心分析逻辑 (纯 TS，无 Runtime 依赖)
│   │   ├── adapters/       # 适配层
│   │   │   ├── db.bun.ts   # Bun SQLite 实现
│   │   │   └── db.node.ts  # Node SQLite 实现
│   │   ├── server.ts       # Elysia 入口
│   │   └── index.ts        # 启动脚本
│   └── package.json
├── frontend/ (React + Vite)
└── docs/
```

## 6. 开发阶段规划

1.  **Phase 1: Bun 核心构建 (MVP)**:
    *   使用 Bun 快速搭建后端，接入 Tree-sitter WASM。
    *   完成基础可视化。
2.  **Phase 2: Git集成与兼容层**:
    *   实现 Git 历史分析。
    *   抽离 DB 适配层，验证 Node.js 兼容性。
3.  **Phase 3: 优化与打包**:
    *   使用 `bun build` 生成单文件可执行程序。

---

此方案确立了 **"Bun First, Node Compatible"** 的战略，既满足了 Vibe Coding 对开发效率和性能的极致追求，又保留了对特殊信创环境的底线兼容能力。
