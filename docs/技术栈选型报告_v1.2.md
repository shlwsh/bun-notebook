# 技术栈选型报告 (Beta版 - Vibe Coding专用)
版本：v1.2

## 1. 核心决策：回归 Bun

**结论：** 本项目将坚定采用 **Bun** 作为首选运行时，仅在不支持的边缘架构上降级为 Node.js。

### **为什么 Bun 是 Vibe Coding 的天作之合？**

在 AI 辅助编程（Vibe Coding）场景下，**"可执行性"** 和 **"上下文清晰度"** 是关键：
1.  **Zero-Config TypeScript**: AI 生成代码通常以 TypeScript 为主。Bun 原生支持 TS，无需 `tsconfig.json`, `ts-node`, `babel` 等复杂配置。**AI 写完，马上就能跑**，这是 Vibe Coding 的生命线。
2.  **单文件原则**: Bun 的 API 设计高度集成（内置 SQLite, Server, Test）。AI 可以在单个文件中写完逻辑+数据库+测试，极大降低了上下文的碎片化，提升 AI 理解准确度。
3.  **极速反馈**: Vibe Coding 是 "生成-运行-修正" 的高频循环。Bun 的毫秒级启动速度能显著提升这一循环的效率。

---

## 2. 后端技术栈 (高性能主选)

### **Runtime: Bun**
*   **性能**: 启动速度比 Node.js 快 4倍+，HTTP 吞吐量高且内存占用低。
*   **信创兼容性**: 
    *   **完美支持**: 鲲鹏/飞腾 (Linux ARM64), 海光/兆芯 (Linux x64)。
    *   **应对方案**: 对于不支持的架构（如龙芯 LoongArch），我们的代码将保持 **Node.js 兼容性**，可无缝切换。

### **Web Framework: ElysiaJS**
*   **选型依据**:
    *   **Bun 的亲儿子**: 完美释放 Bun 的性能，类型推导能力极强（Type Integrity），能自动为前端生成类型定义，减少 AI "幻觉" 导致的接口类型不匹配问题。
    *   **性能怪兽**: 性能表现优于 Fastify。

### **解析引擎: Tree-sitter**
*   **策略**: 保持不变。Bun 可以直接加载 WebAssembly (WASM) 版本的 Tree-sitter，这比 Node bindings 更便携，真正做到 "Write Once, Run Anywhere"。

---

## 3. 前端技术栈 (保持不变)

*   **框架**: React 18 + Vite (Bun 运行 Vite 速度极快)
*   **可视化**: React Flow
*   **UI库**: Shadcn/UI (基于 Tailwind，代码即样式，AI 容易修改)

---

## 4. 部署与兼容性策略

### **策略 A: Bun 单文件交付 (推荐)**
利用 `bun build --compile` 将整个应用（前端静态资源+后端API+数据库）打包成一个**独立的二进制文件**。
*   **优点**: 部署极其简单，无环境依赖，启动即用。
*   **高性能**: 保留了 Bun 的所有性能优势。

### **策略 B: Docker 容器交付 (兜底)**
如果目标环境极其特殊，提供标准的 Docker 镜像（支持 amd64/arm64），屏蔽底层 OS 差异。

### **策略 C: Node.js 兼容模式 (极端保底)**
ElysiaJS 提供 Node.js 适配层。如果必须在龙芯等架构运行，我们只需切换启动入口文件，即可在 Node.js 环境下运行。

---

## 5. 总结

我们不应该为了极少数的极端信创场景（如龙芯旧版）而牺牲 99% 开发过程中的效率和体验。
**Bun + Elysia** 是当前 Vibe Coding 模式下的最优解，兼顾了开发效率（AI 友好）和运行效率（高性能）。
同时，通过打包技术和 Docker，我们依然能满足绝大多数信创交付要求。
