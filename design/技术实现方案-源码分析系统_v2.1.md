# 源码分析与 AI 开发管控系统 - 技术实现方案 v2.1 (Vibe Coding Edition)

**版本**: 2.1  
**日期**: 2026-01-11  
**状态**: 草案  
**基于**: 方案 A (Tauri + Rust) + Vibe Coding 实现理念

---

## 目录

1. [背景与演进](#背景与演进)
2. [Vibe Coding 实施理念](#vibe-coding-实施理念)
3. [总体架构设计](#总体架构设计)
4. [技术栈选型](#技术栈选型)
5. [核心模块设计与测试策略](#核心模块设计与测试策略)
6. [接口设计](#接口设计)
7. [项目结构规划](#项目结构规划)
8. [Vibe Coding 开发阶段规划](#vibe-coding-开发阶段规划)
9. [性能指标与优化](#性能指标与优化)
10. [风险评估](#风险评估)
11. [附录](#附录)

---

## 背景与演进

### v2.0 -> v2.1 的变更动因

在 v2.0 确立了 **Tauri + Rust** 的技术路线后，为确保项目的高质量交付和快速迭代，v2.1 引入了 **Vibe Coding** 的开发理念，重点增强了**测试驱动**和**任务原子化拆解**。

| 维度 | v2.0 方案 | v2.1 方案 (当前) |
|------|-----------|------------------|
| **开发模式** | 传统周维度迭代 | Vibe Coding (Prompt-Driven + Atomic Tasks) |
| **测试策略** | 仅功能验证 | **测试驱动开发 (TDD) + 强制集成测试** |
| **质量保障** | 人工验证为主 | **CI/CD 自动化 + 单元/集成测试全覆盖** |
| **任务粒度** | 粗粒度 (Epic/Feature) | **原子粒度 (Task/Action)**，适合 AI 辅助生成 |

---

## Vibe Coding 实施理念

1.  **AI Pair Programming**: 所有核心逻辑优先由 AI 生成原型，人工进行审查和优化。
2.  **原子化任务 (Atomic Tasks)**: 将复杂功能拆解为 AI 可一次性通过 `Prompt` 完成的独立小任务（如："实现 Java 类名提取正则" 而非 "实现 Java 解析"）。
3.  **测试优先 (Test First)**: 每个原子任务必须包含对应的单元测试，代码生成后立即验证。
4.  **快速反馈循环**: Code -> Test -> Refactor 循环控制在 10 分钟以内。

---

## 总体架构设计

### 架构图

```mermaid
graph TB
    subgraph "集成测试层 (Integration Tests)"
        E2E[端到端测试 (Playwright)]
        APITests[Command 接口测试]
    end

    subgraph "Tauri 应用层"
        subgraph "前端 UI (WebView)"
            UI[React 18 单页应用]
            Store[状态管理 Zustand]
            Components[可视化组件]
            
            UI --> Store
            UI --> Components
        end
        
        IPC[Tauri IPC 通道]
        
        subgraph "Rust 后端核心"
            Commands[Tauri Commands]
            
            subgraph "服务层 (Service Layer)"
                ParserService[代码解析服务]
                AnalysisService[分析服务]
                GitService[Git 操作服务]
                GovernanceService[治理引擎服务]
            end
            
            subgraph "引擎层 (Engine Layer)"
                TreeSitter[Tree-sitter 原生]
                DependencyGraph[依赖图构建器]
                MetricsEngine[度量计算引擎]
                RiskEngine[风险检测引擎]
            end
            
            subgraph "数据层 (Data Layer)"
                GraphDB[图数据库 petgraph]
                CacheDB[SQLite rusqlite]
            end
            
            Commands --> ParserService
            Commands --> AnalysisService
            Commands --> GitService
            Commands --> GovernanceService
            
            ParserService --> TreeSitter
            AnalysisService --> DependencyGraph
            AnalysisService --> MetricsEngine
            GovernanceService --> RiskEngine
            
            DependencyGraph --> GraphDB
            ParserService --> CacheDB
        end
        
        UI -.IPC.-> Commands
    end
    
    E2E -.-> UI
    APITests -.-> Commands
```

---

## 技术栈选型

（保持 v2.0 的核心选型，新增测试工具链）

### 4.1 测试工具链

| 类型 | 工具 | 用途 |
|------|------|------|
| **Rust 单元测试** | `cargo test` | 核心逻辑、算法验证 |
| **Rust Mock** | `mockall` | 模拟 I/O、数据库操作 |
| **Tauri 集成测试** | `tauri-plugin-test` | 测试 IPC Command 接口 |
| **前端单元测试** | `Vitest` | 组件渲染、Store 状态逻辑 |
| **端到端测试** | `Playwright` | 完整业务流程验证 |

---

## 核心模块设计与测试策略

### 5.1 代码解析服务 (ParserService)

#### 功能职责
- Tree-sitter 原生解析
- 符号提取 (Symbol Extraction)
- 增量缓存

#### 测试策略
1.  **单元测试 (Unit Tests)**:
    -   `test_parser_initialization`: 验证 parser 正确加载语言包。
    -   `test_extract_symbols_ts`: 针对 TypeScript 样例代码，验证 Class/Function/Variable 提取准确性。
    -   `test_extract_symbols_java`: 针对 Java 样例代码，验证注解和内部类提取。
    -   `test_syntax_error_handling`: 验证对有语法错误代码的容错处理。
2.  **集成测试 (Integration Tests)**:
    -   `test_parse_directory`: 在真实文件系统中解析包含 100+ 文件的目录，验证并发处理和汇总结果。

```rust
// 示例测试规约
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_symbols_simple_class() {
        let code = "class User { name: string; }";
        let symbols = extract_symbols(code, Language::TypeScript);
        assert_eq!(symbols.len(), 1);
        assert_eq!(symbols[0].name, "User");
        assert_eq!(symbols[0].kind, SymbolKind::Class);
    }
}
```

### 5.2 依赖分析服务 (AnalysisService)

#### 功能职责
- 构建模块依赖图 (Dependency Graph Construction)
- 循环依赖检测 (Cycle Detection)

#### 测试策略
1.  **单元测试**:
    -   `test_import_resolution`: 验证相对路径、别名路径 (`@/components/...`) 的解析逻辑。
    -   `test_cycle_detection`: 构造 A->B->C->A 的依赖图，验证算法能否准确识别。
2.  **集成测试**:
    -   `test_build_graph_from_fixture`: 使用预定义的复杂项目 Fixture，验证生成的图节点数和边数是否符合预期。

### 5.3 Git 集成服务 (GitService)

#### 功能职责
- Git 历史读取
- 代码热力图计算

#### 测试策略
1.  **单元测试**:
    -   `test_heatmap_calculation`: 给定一组 Commit 数据，验证热力值计算公式。
2.  **集成测试**:
    -   `test_git_history_reading`: 在临时目录创建一个真实 Git 仓库，提交若干次，验证 `get_history` 接口返回的数据准确性。使用 `tempfile` crate 创建临时环境。

---

## 接口设计 (Tauri Commands)

（保持 v2.0 基础设计，增加错误码规范）

### 错误处理规范

所有 Command 必须返回 `Result<T, CommandError>`，其中 `CommandError` 需包含明确的错误码：

```rust
#[derive(Debug, Serialize)]
pub struct CommandError {
    pub code: String,    // e.g., "PARSER_ERROR_001"
    pub message: String, // 用户友好的错误信息
    pub details: Option<String>,
}
```

---

## Vibe Coding 开发阶段规划

在此模式下，每个阶段由具体的**任务清单**组成，每个任务执行遵循：**定义接口 -> 生成测试 -> 生成实现 -> 验证通过**。

### 阶段 1: 核心解析引擎 (Week 1)

**目标**: 实现高性能文件解析，建立测试基础设施。

- [ ] **Task 1.1: 工程脚手架与 CI 配置**
    - 创建 Tauri 项目。
    - 配置 GitHub Actions (Build & Test)。
    - **验证**: CI 流水线绿灯。
- [ ] **Task 1.2: Tree-sitter 基础集成**
    - 引入 `tree-sitter` 及 TypeScript/Java binding。
    - 实现 `Parser` 结构体封装。
    - **测试**: `test_parser_init` (单元测试)。
- [ ] **Task 1.3: 符号提取逻辑 (TypeScript)**
    - 定义 `Symbol` 数据结构。
    - 实现 TS Query 文件。
    - **测试**: `test_extract_ts_class`, `test_extract_ts_function`。
- [ ] **Task 1.4: 并行文件扫描与处理**
    - 使用 `rayon` 实现目录遍历和并发解析。
    - **测试**: `test_parse_large_directory` (集成测试，性能基准)。

### 阶段 2: 依赖透视系统 (Week 2)

**目标**: 构建依赖关系图，通过数据可视化验证核心价值。

- [ ] **Task 2.1: 导入语句解析器**
    - 实现 Regex 或 Tree-sitter query 提取 `import ... from ...`。
    - **测试**: `test_resolve_relative_import`, `test_resolve_alias_import`。
- [ ] **Task 2.2: 图数据结构构建**
    - 集成 `petgraph`。
    - 实现 `GraphBuilder`。
    - **测试**: `test_add_node_edge`。
- [ ] **Task 2.3: 循环依赖检测算法**
    - `tarjan_scc` 算法封装。
    - **测试**: `test_detect_cycle_simple`, `test_detect_cycle_complex`。
- [ ] **Task 2.4: 前端可视化对接**
    - 定义 `GraphData` 接口。
    - React Flow 组件实现。
    - **测试**: Playwright 端到端测试，验证图节点渲染。

### 阶段 3: 演进与治理 (Week 3)

**目标**: 引入时间维度 (Git) 和质量维度 (Governance)。

- [ ] **Task 3.1: Git 仓库操作封装**
    - 集成 `git2-rs`。
    - 实现 `get_commit_log`。
    - **测试**: `test_read_demo_repo` (临时 Git 库集成测试)。
- [ ] **Task 3.2: 变更影响分析**
    - 结合依赖图和 Git 变更文件，计算受影响范围。
    - **测试**: `test_impact_analysis`。
- [ ] **Task 3.3: 治理规则引擎**
    - 定义规则接口 trait。
    - 实现 "禁止循环依赖" 规则。
    - **测试**: `test_rule_execution`。

---

## 验证与验收

每个阶段的验收标准（Definition of Done）：

1.  **所有单元测试通过** (`cargo test` 100% pass)。
2.  **核心路径集成测试通过**。
3.  **Rust 代码通过 Clippy 检查** (`cargo clippy -- -D warnings`)。
4.  **无新增严重 Bug**。
5.  **AI 生成代码经过人工 Review**。

---

## 风险评估与缓解 (v2.1 更新)

| 风险点 | 概率 | 缓解措施 (Vibe Coding) |
|--------|------|------------------------|
| **AI 生成代码包含隐蔽 Bug** | 中 | 强制要求生成对应的单元测试；人工 Code Review 重点关注边界条件。 |
| **测试代码编写耗时** | 高 | 利用 AI 生成测试脚手架和 Mock 数据，人只需补充断言逻辑。 |
| **集成测试环境复杂** | 中 | 使用 Docker 或临时目录 (`tempfile`) 隔离测试环境，确保可重复性。 |

---

## 总结

v2.1 方案在 v2.0 的技术架构之上，注入了 **Vibe Coding** 的灵魂。通过极细粒度的任务拆解和严格的测试驱动开发流程，我们不仅能利用 AI 提高开发效率，更能通过自动化测试网确保代码质量，真正实现“快而不破”。
